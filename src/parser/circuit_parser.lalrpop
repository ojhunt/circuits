use crate::parser::ast::*;

grammar;

pub TypeName: Ident = {
    r"[A-Z][a-zA-Z_0-9]*" => Ident::new(<>),
    r"_[A-Z][a-zA-Z_0-9]*" => Ident::new(<>),
}

pub VariableName: Ident = {
    r"[a-z][a-zA-Z_0-9]*" => Ident::new(<>),
    r"_[a-z][a-zA-Z_0-9]*" => Ident::new(<>),
}

Comma<T>: Vec<T> = { // (1)
    <v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub TypeArgument : TypeArgument = {
    <TypeReference> => TypeArgument::Type(Box::new(<>)),
    <ExprNoLTGT> => TypeArgument::Value(Box::new(<>))
}

pub TypeReference : TypeReference = {
    <TypeName> => TypeReference::Resolve(<>),
    <base: TypeReference> "<" <parameters:Comma<TypeArgument>> ">" => TypeReference::Apply(Box::new(base), parameters),
    <base: TypeReference> "::" <name: TypeName> => TypeReference::Access(Box::new(base), name),
    "[" <Expr> "]" => TypeReference::Bus(None, Box::new(<>)),
    <base: TypeReference>  "[" <subscript: Expr> "]" => TypeReference::Bus(Some(Box::new(base)), Box::new(subscript)),
}

pub TypeParameter : TypeParameter = {
    <id:TypeName> <constraint: (":" <TypeReference>)?> => TypeParameter::new(id, constraint),
    <id:VariableName> <constraint: (":" <TypeReference>)> => TypeParameter::new(id, Some(constraint))
}

pub IOPort : IOPort = {
    "in" <name:VariableName> ":" <ty: TypeReference> => IOPort::In(name, ty),
    "out" <name:VariableName> ":" <ty: TypeReference> => IOPort::Out(name, ty),
}

pub Circuit : Circuit = {
    "circuit" <id:TypeName> <instance_parameters: ("<" <Comma<TypeParameter>> ">")?> <init_parameters: ("(" <Comma<IOPort>> ")")?> <constraints: ("where" <Expr>)?> "{" <declarations: Declaration*> "}" => {
        Circuit::new(id, instance_parameters, declarations)
    }
}

pub Literal : Expression = {
    r"0[bB][01]+" => Expression::Vector((<>)[2..].chars().map(|a| a == '1').collect()),
    r"0[xX][0-9a-f]+" => {
        Expression::Integer(usize::from_str_radix(&(<>)[2..], 16).unwrap())
    }
}

pub PrimaryExpression : Expression = {
    <id:VariableName> => Expression::Resolve(id),
    Literal => <>,
    "(" <expr:Expr> ")" => expr,
}

pub MemberExpression : Expression = {
    PrimaryExpression => <>,
    <e:MemberExpression> "[" <subscript: Expr> "]" =>
        Expression::BracketAccess(Box::new(e), Box::new(subscript)),
    <base:TypeReference> "::" <property: VariableName> => 
        Expression::TypeAccess(Box::new(base), property),
    <base:MemberExpression> "." <property: VariableName> => 
        Expression::Nested(Box::new(base), property),
}

pub OperatorsNoLTGT : Ident = {
    r"[!+-@$%^&*~]+" => Ident::new(<>),
}

pub Operators : Ident = {
    OperatorsNoLTGT => <>,
    "<" => Ident::new(<>),
    ">" => Ident::new(<>),
}

BinaryOperator<Operators> : Ident = {
    "`" <name: VariableName> "`" => name,
    Operators => <>,
}

UnaryExpr<Operators> : Expression = {
    <e: MemberExpression> => e,
    <op: Operators> <e: MemberExpression> => Expression::Unary(op, Box::new(e))
}

BinaryTail<Operators> : BinaryTail = {
    <op:Operators> <e: UnaryExpr<Operators>> => BinaryTail{operation: op, expression: e}
}

pub Expr : Expression = {
    <expr: UnaryExpr<Operators>> <tail: (<BinaryTail<Operators>>)*> => Expression::Binary(Box::new(expr), tail),
}
pub ExprNoLTGT : Expression = {
    <expr: UnaryExpr<OperatorsNoLTGT>> <tail: (<BinaryTail<OperatorsNoLTGT>>)*> => Expression::Binary(Box::new(expr), tail),
}

pub Declaration : Declaration = {
    Circuit => Declaration::Circuit(Box::new(<>)),
    "type" <id:TypeName> <parameters: ("<" <Comma<TypeParameter>> ">")?> "=" <ty: TypeReference> => Declaration::TypeAlias(id, parameters.unwrap_or(Vec::new()), ty)
}

pub Module : Module = {
    "module" <id:TypeName> ";" <declarations: Declaration*> => {
        Module::new(id, declarations)
    }
}