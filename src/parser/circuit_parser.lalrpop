use crate::parser::ast::*;

grammar;

pub Id: Ident = { 
    r"[a-zA-Z_][a-zA-Z_0-9]*" => Ident::new(<>)
}

Comma<T>: Vec<T> = { // (1)
    <v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub TypeParameter : TypeParameter = {
    <id:Id> <constraint: (":" <TypeRef>)?> => TypeParameter::new(id, constraint)
}

pub IOPort : IOPort = {
    "in" <name:Id> ":" <ty: TypeRef> => IOPort::In(name, ty),
    "out" <name:Id> ":" <ty: TypeRef> => IOPort::Out(name, ty),
}

pub Circuit : Circuit = {
    "circuit" <id:Id> <instance_parameters: ("<" <Comma<TypeParameter>> ">")?> <init_parameters: ("(" <Comma<IOPort>> ")")?> <constraints: ("where" <Expr>)?> "{" <declarations: Declaration*> "}" => {
        Circuit::new(id, instance_parameters, declarations)
    }
}

pub Literal : Expression = {
    r"0[bB][01]+" => Expression::Vector((<>)[2..].chars().map(|a| a == '1').collect()),
    r"0[xX][0-9a-f]+" => {
        Expression::Integer(usize::from_str_radix(&(<>)[2..], 16).unwrap())
    }
}

pub PrimaryExpression : Expression = {
    <id:Id> => Expression::Resolve(id),
    Literal => <>,
    "(" <expr:Expr> ")" => expr,
}

pub MemberExpression : Expression = {
    PrimaryExpression => <>,
    <e:MemberExpression> "[" <subscript: Expr> "]" =>
        Expression::BracketAccess(Box::new(e), Box::new(subscript)),
    <base:MemberExpression> "::" <property: Id> => 
        Expression::Nested(Box::new(base), property),
    <base:MemberExpression> "." <property: Id> => 
        Expression::Nested(Box::new(base), property),
}

pub BinaryOperator : Ident = {
    "`" <name: Id> "`" => name,
    r"[!+-=<>@$%^&*]+" => Ident::new(<>)
}

pub UnaryExpr : Expression = {
    <e: MemberExpression> => e,
    <op: BinaryOperator> <e: MemberExpression> => Expression::Unary(op, Box::new(e))
}

pub BinaryTail : BinaryTail = {
    <op:BinaryOperator> <e: UnaryExpr> => BinaryTail{operation: op, expression: e}
}
pub Expr : Expression = {
    <base: UnaryExpr> => base,
    <expr: UnaryExpr> <tail: (<BinaryTail>)+> => Expression::Compound(Box::new(expr), tail),
}

pub TypeRef : TypeRef = {
    Id => TypeRef::Resolve(<>),
    <base: TypeRef> "<" <parameters: Comma<Expr>> ">" => TypeRef::Apply(Box::new(base), parameters),
    <base: TypeRef> "::" <id: Id> => TypeRef::Nested(Box::new(base), id),
    <base: TypeRef> "[" <value: Expr> "]" => TypeRef::Bus(Box::new(base), Box::new(value))
}

pub Declaration : Declaration = {
    Circuit => Declaration::Circuit(Box::new(<>)),
    "type" <id:Id> <parameters: ("<" <Comma<TypeParameter>> ">")?> "=" <ty: TypeRef> => Declaration::TypeAlias(id, parameters.unwrap_or(Vec::new()), ty)
}

pub Module : Module = {
    "module" <id:Id> ";" <declarations: Declaration*> => {
        Module::new(id, declarations)
    }
}