use crate::parser::ast::*;

grammar;

pub Id: Ident = { 
    r"[a-zA-Z_][a-zA-Z_0-9]*" => Ident::new(<>)
}

Comma<T>: Vec<T> = { // (1)
    <v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub TypeParameter : TypeParameter = {
    <id:Id> <constraint: (":" <TypeRef>)?> => TypeParameter::new(id, constraint)
}

pub Circuit : Circuit = {
    "circuit" <id:Id> <parameters: ("<" <Comma<TypeParameter>> ">")?> "{" <declarations: Declaration*> "}" => {
        Circuit::new(id, parameters, declarations)
    }
}

pub Literal : Expression = {
    r"0[bB][01]+" => Expression::Vector((<>)[2..].chars().map(|a| a == '1').collect()),
    r"0[xX][0-9a-f]+" => {
        Expression::Integer(usize::from_str_radix(&(<>)[2..], 16).unwrap())
    }
}

pub Expr : Expression = {
    <id:Id> => Expression::Resolve(id),
    <e:Expr> "." <id:Id> => Expression::DotAccess(Box::new(e), id),
    <e:Expr> "[" <subscript:Expr> "]" => 
        Expression::BracketAccess(Box::new(e), Box::new(subscript)),
    <base:Expr> "<" <parameters: Comma<Expr>> ">" => 
        Expression::TypeApplication(Box::new(base), parameters),
    <base:Expr> "::" <property: Id> ">" => 
        Expression::Nested(Box::new(base), property),
    Literal => <>,
}

pub TypeRef : TypeRef = {
    Id => TypeRef::Resolve(<>),
    <base: TypeRef> "<" <parameters: Comma<Expr>> ">" => TypeRef::Apply(Box::new(base), parameters),
    <base: TypeRef> "::" <id: Id> => TypeRef::Nested(Box::new(base), id)

}

pub Declaration : Declaration = {
    Circuit => Declaration::Circuit(Box::new(<>)),
    "type" <id:Id> <parameters: ("<" <Comma<TypeParameter>> ">")?> "=" <ty: TypeRef> => Declaration::TypeAlias(id, parameters.unwrap_or(Vec::new()), ty)
}

pub Module : Module = {
    "module" <id:Id> ";" <declarations: Declaration*> => {
        Module::new(id, declarations)
    }
}